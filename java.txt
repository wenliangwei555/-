趁没人在 提交以下

中级程序员必会的高薪技能
快速入门Zookeeper+dubbo     
完整视频：http://yun.itheima.com/course/603.html?2001zzp
配套资料：https://pan.baidu.com/s/148DQLvkgXkFcDC7hNc9b_w 提取码：atcv


平台的表
ms  营销  26张
bms 内管  18张
ams 账户  24张
rms 报表  61张
dms&cms 综合和收费  56张 
pds 物业基础 63张
me  信息交互 8张
pas 工作流   33张
us  用户     19张
bcc 渠道  23张  


JavaJDK新特性详解
完整视频：http://yun.itheima.com/course/612.html?2001zzp
配套资料：https://pan.baidu.com/s/1iuWzz5BatmxXkRCDIvThOg 提取码：guh9

揭秘Java新贵---kafka企业级入门实战
完整视频：http://yun.itheima.com/open/452.html?2001zzpts
配套资料：https://pan.baidu.com/s/14PAxHEVpnKbOdGKzoHVe5g  提取码：jyud


Java提升-Tomcat核心原理解析
完整视频：http://yun.itheima.com/course/569.html?2001zzpqq
配套资料：https://pan.baidu.com/s/1_lIoUoGhbYnqrmAFzwXJrA 提取码：smwt

锁定offer必备，深度剖析Java核心技术（分布式集群  完整视频：+源码+笔记 ）
完整视频：http://yun.itheima.com/open/414.html?2001zzp1
配套资料：https://pan.baidu.com/s/1Vgb-KCMY6QAzuUZ5YOJjqA  提取码：0rz9

JAVA完整游戏项目开发：大咖带你玩得风生水起 (超级玛丽)
完整视频：http://yun.itheima.com/open/404.html?2001zzpqq
配套资料：https://pan.baidu.com/s/1aiHz5txPxnt2PenUBpE_iA 提取码：cuw2


零起点打开Java世界的大门
完整视频：http://yun.itheima.com/course/540.html?2001zzpqq 
配套资料：https://pan.baidu.com/s/1YsAZBwgrdXY-hypsmH6o1w 提取码：egtf

Javascript基础加强视频（新）
完整视频：http://yun.itheima.com/course/182.html?2001zzpqq
配套资料：https://pan.baidu.com/s/15loi5E9z9f8CrtL7bYmDTw 提取码：r2hm

黑马程序员_JavaWeb网上图书商城完整项目视频
完整视频：http://yun.itheima.com/course/35.html?2001zzpqq
配套资料：https://pan.baidu.com/s/1ZyH-VqDyl-nwRGr8xN58xw 提取码：2lal


https://www.cs.usfca.edu/~galles/visualization/Algorithms.html   数据结构可视化


tcp协议和udp协议的差别 
           TCP           UDP 
是否连接     面向连接     面向非连接 
传输可靠性   可靠        不可靠 
应用场合    少量数据    传输大量数据 

速度       慢         快




面向过程

优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 
缺点：没有面向对象易维护、易复用、易扩展

面向对象

优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 
缺点：性能消耗大




简述 java 垃圾回收机制? 在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在
JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚
拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将
它们添加到要回收的集合中，进行回收。

jps: 查看本机的Java中进程信息。
jstack: 打印线程的执行栈信息。
jmap: 打印内存映射,制作堆Dump。
jstat: 性能监控工具。
jhat: 内存分析工具。
jconsole:简易的可视化控制台。
jvisualvm:功能强大的控制台。
------------------------------------------------------------------------------------------------------------------------------
正常创建。通过 new 操作符
反射创建。调用 Class 或 java.lang.reflect.Constructor 的 newInstance()方法
克隆创建。调用现有对象的 clone()方法
发序列化。调用 java.io.ObjectInputStream 的 getObject()方法反序列化
----------------------------------------------------------------------------------------------------------------------------
jvm的组件 包括啦类加载器  运行时数据区  执行引擎  本地库接口  


jvm的 运行时数据区 分区 
堆区 : 分为新生代 和老年代 新生代分为eden 区 survivalfrom区和survivalto区   
新创建的对象在新生区 第一次gc开始    (复制整理算法) 会把新生区存活的对象复制到 survivalto区  
survivalfrom区会根据对象的年龄决定 对象的去向 达到阈值 会被移入老年代  没达到的被复制到survivalto区 
然后清理 新生区 和 survivalfrom区  survivalfrom和survivalto相互转换  维持survivalto是空的  直到to 的幸存区被填满 
每经历过一次gc后的对象就会加一岁   年龄到一定程度(15)岁会被移入到老年代  

栈区 :栈的结构是栈帧  每次调用一个方法就会压入一帧  帧上存储这局部变量表 操作数栈  动态链接  方法出口等信息 
还是指向地址的指针
局部变量表  : 包含啦八大基本数据类型 和一个对象引用  索引来访问 
操作数栈   :和 局部变量表一样   标准的栈操作 来访问数据 用于计算的临时储存区 用来存储运算结果以及运算的操作数
动态链接:  编译过的字节码会有大量的符号引用  在运行时使用就是动态链接   在编译是使用就是静态链接
方法出口: 就是执行完子方法 返回主方法原有位置的继续执行 

方法区(元空间) : 储存类的信息 常量池(静态的) 还有编译过的代码等 被jvm线程共享的

本地方法栈
要用来存储运算结果以及运算的操作数

pc寄存器(程序计数器)
内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码
指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内
存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域

-----------------------------------------------------------------------------------------------------------------------
@enablescheduling  //标识这个定时任务类 开启  
@scheduled (cron="表达式")  //方法注解
表达式例子：

0 * * * * ? 每1分钟触发一次
0 0 * * * ? 每天每1小时触发一次
0 0 10 * * ? 每天10点触发一次
0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 
0 30 9 1 * ? 每月1号上午9点半
0 15 10 15 * ? 每月15日上午10:15触发

*/5 * * * * ? 每隔5秒执行一次
0 */1 * * * ? 每隔1分钟执行一次
0 0 5-15 * * ? 每天5-15点整点触发
0 0/3 * * * ? 每三分钟触发一次
0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 
0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发
0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时
0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 

0 0 12 ? * WED 表示每个星期三中午12点
0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点
0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 
0 15 10 ? * MON-FRI 周一至周五的上午10:15触发

0 0 23 L * ? 每月最后一天23点执行一次
0 15 10 L * ? 每月最后一日的上午10:15触发 
0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 

0 15 10 * * ? 2005 2005年的每天上午10:15触发 
0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 
0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发

------------------------------------------------------------------------------------------------------------------------------


一.面向对象的三大基本特性

　　1.封装
　　封装，就是把客观事物封装成抽象的类，并且类可以使自己的数据和方法只让可信的类或者对象操作，对不可信的则进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。
　　2.继承
　　继承，指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过 “继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承（又称接口实现）。实现继承是指直接使用 基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。

组合是has a的关系 
继承是is a的关系
为扩展而继承，为复用而组合
　　3.多态
　　多态，是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

　　二.OOP编程的七个基本原则

　　1.单一职责原则SRP(Single Responsibility Principle)

　　类的功能要单一，体积不要过于庞大。
    　SRP是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。
　　2.开放封闭原则OCP(Open－Close Principle)

　　对扩展开放，对修改关闭。
    　一个模块在扩展性方面应该是开放的，而在更改性方面应该是封闭的。比如：一个网络模块，原来只提供服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。
　　3.里式替换原则LSP(the Liskov Substitution Principle)

　　父类出现的地方，子类都可以替换。
    　子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则公司就不和谐了。
　　4.依赖倒置原则DIP(the Dependency Inversion Principle)

　　具体依赖抽象。面向对象、抽象编程，不要面向细节、过程编程。

High level modules should not depend upon low level modules.Both should depend upon abstractions.<br>Abstractions should not depend upon details.<br>Details should depend upon abstracts.
 　　可以翻译为：

高层模块不应该依赖低层模块，两者都应该依赖抽象
抽象不应该依赖细节
细节应该依赖抽象
　　每一个逻辑的实现都是由颗粒原子逻辑组成的，颗粒原子逻辑就是低层模块，而颗粒原子逻辑组成的模块就是高层模块。在java语言中，抽象就是接口或抽象类，两都都是不能直接被实例化的，细节就是实现类，实现接口或继承抽象类而产生的类就是细节，两者都可以直接被实例化。

　　依赖倒置原则在java语言中的表现是：

模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。
接口或抽象类不依赖实现类
实现类依赖接口或抽象类
　　依赖倒置原则可以引申出OOD(Object-Oriented Design，面向对象设计)和OOP（Object-Oriented Programing，面向对象编程）。

　　采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定，降低并行开发引起的风险，提高代码的可读性和可维护性。　　

对象的依赖关系有三种方式来传递：
    ①构造函数传递依赖对象
    在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注入。
    ②Setter方法传递依赖对象
    在类中通过Setter方法声明依赖关系，依照依赖注入的说法，这是Setter依赖注入。
    ③接口声明依赖
    在接口的方法中声明依赖对象，该方法也叫做接口注入。
 　　5.接口分离原则ISP(the Interface Segregation Principle)
　　接口定义的标准尽可能单一，致力于对接口的多实现。接口规模不要臃肿。

　　6.迪米特法则---最少知识原则。类与类之间尽量减少不必要的访问。降低耦合。

　　7.合成复用原则。多用组合/聚合，少用继承，降低耦合度。

　　最后，我们再谈下内聚与耦合。

　　内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。
　　耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。
　　内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。

　　

　　简单地说，软件工程中对象之间的耦合度就是对象之间的依赖性。指导使用和维护对象的主要问题是对象之间的多重依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。有软硬件之间的耦合，还有软件各模块之间的耦合。　　

　　耦合可以分为以下几种，它们之间的耦合度由高到低排列如下：

内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。
公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。
外部耦合。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。
控制耦合。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。
标记耦合。若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。
数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。
非直接耦合。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。
　　总的来说，耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：

　　如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。
--------------------------------------------------------------------------------------------------------------------------------

映射文件中所有的select语句将被缓存
映射文件中所有的insert、update和delete语句将刷新缓存 
缓存将使用LRU（Least Recently Used）最近最少使用策略算法来回收
刷新间隔（no Flush Interval，没有刷新间隔），缓存不会以任何时间顺序来刷新
缓存会存储列表集合和对象（无论查询方法返回什么）的1024个引用 
缓存会被视为read/write（可读/可写）的缓存，意味着对象检索不是共享的，而且可以安全的被调用者修改，而不干扰其他调用者或者线程所做的潜在修改